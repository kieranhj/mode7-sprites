\ ******************************************************************
\ * TeleTexel v1
\ * Music visualiser in MODE 7
\ * Treat MODE 7 as a 76 x 75 pixel canvas (aka teletexels)
\ ******************************************************************


\ ******************************************************************
\ *	Define OS entries (could be INCLUDE bbc_os.h)
\ ******************************************************************

oswrch = &FFEE
osasci = &FFE3
osbyte = &FFF4
osword = &FFF1
EVENTV = &0220

INKEY_esc = 112
INKEY_w = 33
INKEY_s = 81
INKEY_a = 65
INKEY_d = 50

SEI_OP = $78
CLI_OP = $58
NOP_OP = $ea

\ ******************************************************************
\ *	Define debug flags (prefer DEBUG_* naming?)
\ ******************************************************************


\ ******************************************************************
\ *	Define macros (prefer MACRO_* naming?)
\ ******************************************************************

\ ******************************************************************
\ *	Define global constants
\ ******************************************************************

MODE7_base_addr = &7C00
MODE7_char_width = 40
MODE7_char_height = 25

MODE7_alpha_black = 128
MODE7_graphic_black = 144
MODE7_contiguous = 153
MODE7_separated = 154
MODE7_black_bg = 156
MODE7_new_bg = 157

PLOT_origin_col = 4				; skip first 4 coloumns (col + newbg + col + sep)
MODE7_texel_width = (MODE7_char_width - PLOT_origin_col) * 2
MODE7_texel_height = MODE7_char_height * 3

MIRROR_bottom_row = 24
MIRROR_top_row = 22
MIRROR_read_row = MIRROR_top_row - 1

STARS_num = 22


\ ******************************************************************
\ *	Define fast (zero page) runtime variables
\ ******************************************************************

ORG &7B
GUARD &A0

.writeptr				SKIP 2
.readptr				SKIP 2

.test_x					SKIP 1
.test_y					SKIP 1

.plot_ptr				SKIP 2			; ptr to sprite data
.plot_x					SKIP 1			; x coordinate in pixels
.plot_y					SKIP 1			; y coordinate in pixels
.plot_char_w			SKIP 1			; sprite width in chars
.plot_char_h			SKIP 1			; sprite width in chars
.plot_x_offset			SKIP 1			; sprite offset x
.plot_y_offset			SKIP 1			; sprite offset y
.plot_char_x			SKIP 1			; x position in chars absolute
.plot_char_y			SKIP 1			; y position in chars absolute
.plot_char_pitch		SKIP 1			; pitch of sprite data in chars
.plot_diff_x			SKIP 1			; #characters clipped on left edge
.plot_diff_y			SKIP 1			; #character rows clipped on top edge
.plot_linear_byte		SKIP 3			; 3x linear sprite data bytes
.plot_char_byte			SKIP 1

.mirror_byte			SKIP 1
.mirror_bit				SKIP 1

.raster_idx				SKIP 1

\ ******************************************************************
\ *	Start address to be saved
\ ******************************************************************

ORG &1900	      					; code origin (like P%=&2000)
GUARD &7C00							; ensure code size doesn't hit start of screen memory

.start

\ ******************************************************************
\ *	Code entry
\ ******************************************************************

\ ******************************************************************
\ *	Main loop sequencing tick & draw code
\ ******************************************************************

.main
{
	\\ Set MODE 7 for memory
	LDA #22: JSR oswrch
	LDA #7: JSR oswrch
	\\ Turn off cursor!

	JSR teletexel_init
	JSR mode7_starfield_init

	LDA #0
	STA test_x
	STA test_y
	STA raster_idx

	.loop

	\\ Wait for vsync
	LDA #19
	JSR osbyte

;	LDA test_x
;	STA plot_x
;	LDA test_y
;	STA plot_y
;	LDA #LO(starhole)
;	STA plot_ptr
;	LDA #HI(starhole)
;	STA plot_ptr+1
;	JSR mode7_erase_sprite

	\\ Check for Escape key
	{
		LDA #121
		LDX #0
		JSR osbyte
		CPX #INKEY_esc
		BEQ exit

		CPX #INKEY_w
		BNE not_w
		DEC test_y
		.not_w
		CPX #INKEY_s
		BNE not_s
		INC test_y
		.not_s
		CPX #INKEY_a
		BNE not_a
		DEC test_x
		.not_a
		CPX #INKEY_d
		BNE not_d
		INC test_x
		.not_d
	}

	LDA test_x
	STA plot_x
	LDA test_y
	STA plot_y
	LDA #LO(starlin)
	STA plot_ptr
	LDA #HI(starlin)
	STA plot_ptr+1

	JSR mode7_plot_linear

	JSR mode7_raster_fx
	JSR mode7_starfield_fx
	JSR mode7_mirror_fx

	JMP loop

	\\ Until we finish
	.exit

	RTS
}

.teletexel_init
{
	LDX #0

	.loop
	LDA mode7_row_addr_LO,X
	STA writeptr
	LDA mode7_row_addr_HI,X
	STA writeptr+1
	
	LDY #0

	CPX #MIRROR_top_row
	BCC not_mirror
	LDA #MODE7_graphic_black + 4
	STA (writeptr),Y

	INY
	LDA #MODE7_new_bg
	STA (writeptr),Y
	BNE done_mirror

	.not_mirror
	LDA #MODE7_graphic_black + 7
	STA (writeptr),Y

	INY
	LDA #MODE7_black_bg
	STA (writeptr),Y
	
	.done_mirror
	INY
	LDA #MODE7_contiguous
	STA (writeptr),Y

	INY
	LDA #MODE7_graphic_black + 7
	STA (writeptr),Y

	INX
	CPX #MODE7_char_height
	BCC loop

	.return
	RTS
}


\ ******************************************************************
\ *	Sprite plot routine
\ * Want the interface to be something like:
\ * Sprite data address = plot_ptr
\ * X coordinate, Y coordinate = plot_x, plot_y
\ ******************************************************************

.mode7_plot_sprite
{
	\\ Zero any temporary variables
	LDY #0
	STY plot_diff_x
	STY plot_diff_y

	\\ Copy width and height in chars (bytes)
	LDA (plot_ptr),Y
	STA plot_char_w
	STA plot_char_pitch				; store pitch
	INY
	LDA (plot_ptr),Y
	STA plot_char_h

	\\ Calculate x,y offset from coordinates
	LDA plot_x
	AND #1
	STA plot_x_offset

	\\ Calculate absolute x,y character pos from coordinates
	LDA plot_x
	BPL no_clip_left

	\\ x < 0
	\\ Make positive
	EOR #&FF						; flip bits + 1
	CLC
	ADC #2							; add 1 as as need to correctly round to chars
	LSR A							; div 2
	STA plot_diff_x					; this is the diff to clip in chars

	\\ Reduce width by diff			
	SEC
	LDA plot_char_w
	SBC plot_diff_x					; could just add this
	BPL visible_left				; w - x < 0 so plot position is off screen

	.jump_not_visible
	JMP not_visible					; stupid branch range
	
	.visible_left
	STA plot_char_w

	\\ Reset x
	LDA #0							; x=0

	.no_clip_left
	LSR A							; relative
	CLC
	ADC #PLOT_origin_col			; make absolute
	STA plot_char_x

	\\ Check if not visible
	CMP #MODE7_char_width
	BCS jump_not_visible			; x > 40 so plot position is off screen

	\\ Now test for right clip by adding width
	CLC
	ADC plot_char_w
	CMP #MODE7_char_width
	BCC no_clip_right

	\\ Is over width of screen
	; Carry set
	LDA #MODE7_char_width
	SBC plot_char_x
	STA plot_char_w					; clip width = 40 - x

	.no_clip_right

	\\ Look up y coordinate
	LDY plot_y

	LDA mod3_table, Y
	STA plot_y_offset

	\\ y < 0?
	TYA
	BPL no_clip_top

	\\ Make positive

	EOR #&FF					; flip the bits +1 then -1
	TAY

	CLC
	LDA div3_table, Y			; char row = y DIV 3
	ADC #1						; when negative need one more char row`
	STA plot_diff_y

	SEC
	LDA plot_char_h
	SBC plot_diff_y				; subtract clipped character rows from height
	STA plot_char_h

	BEQ jump_not_visible		; if h <= 0 then not visible
	BMI jump_not_visible

	LDY #0

	.no_clip_top
	LDA div3_table, Y
	STA plot_char_y

	\\ Check if not visible off bottom
	CMP #MODE7_char_height
	BCS jump_not_visible			; y > 25 so plot position is off screen

	\\ Now test for bottom clip by adding height
	CLC
	ADC plot_char_h
	CMP #MODE7_char_height
	BCC no_clip_bottom

	\\ Is over height of screen
	; Carry set
	LDA #MODE7_char_height
	SBC plot_char_y
	STA plot_char_h					; clip height = 25 - y

	.no_clip_bottom

	\\ Calculate screen address from coordinates
	LDY plot_char_y

	\\ Look up address of row from y coordinates
	CLC
	LDA mode7_row_addr_LO,Y
	ADC plot_char_x
	STA store_screen_addr+1			; ** MODIFIES CODE
	LDA mode7_row_addr_HI,Y
	ADC #0
	STA store_screen_addr+2			; ** MODIFIES CODE

	\\ Locate sprite data = x_offset*6 + y_offset*2 - ick
	CLC
	LDA plot_x_offset
	BEQ x_offset_zero
	LDA #6							; 3x y offsets * 2x bytes
	.x_offset_zero
	ADC plot_y_offset
	ADC plot_y_offset
	ADC #2							; skip w & h bytes

	TAY

	\\ Then read off the data address LO & HI - mmph
	CLC
	LDA (plot_ptr),Y
	ADC plot_diff_x					; offset into sprite data for clip
	STA load_sprite_data+1
	INY
	LDA (plot_ptr),Y
	STA load_sprite_data+2

	\\ If we're clipped off the top we need to start from inside the sprite data
	{
		LDY plot_diff_y
		.loop
		BEQ done
		CLC
		LDA load_sprite_data+1
		ADC plot_char_pitch
		STA load_sprite_data+1
		LDA load_sprite_data+2
		ADC #0
		STA load_sprite_data+2
		DEY
		BNE loop
		.done
	}

	\\ Plot loop

	\\ For each row
	LDY plot_char_h
	.y_loop

	\\ Plot all chars
	LDX #0							; start at left clip
	.x_loop
	CPX plot_char_w
	BCS done_x_loop
	.load_sprite_data
	LDA end,X						; ** SELF-MODIFIED CODE
	.store_screen_addr
	STA &7C00,X						; ** SELF-MODIFIED CODE
	INX
	JMP x_loop

	.done_x_loop
	DEY
	BEQ done_y_loop

	\\ Next line
	CLC
	LDA store_screen_addr+1
	ADC #MODE7_char_width			; screen pitch
	STA store_screen_addr+1
	LDA store_screen_addr+2
	ADC #0
	STA store_screen_addr+2
	
	\\ Next data - gah this is continuous
	CLC
	LDA load_sprite_data+1
	ADC plot_char_pitch				; sprite pitch
	STA load_sprite_data+1
	LDA load_sprite_data+2
	ADC #0
	STA load_sprite_data+2

	JMP y_loop
	.done_y_loop
	.not_visible

	.return
	RTS
}

.mode7_plot_linear
{
	\\ Copy width and height in byte
	LDY #0
	STY plot_diff_x
	STY plot_diff_y 

	LDA (plot_ptr),Y
	STA plot_char_w
	STA plot_char_pitch				; store pitch
	INY
	LDA (plot_ptr),Y
	STA plot_char_h

	\\ Calculate character coordiantes
	LDA plot_x
	LSR A
	CLC
	ADC #PLOT_origin_col
	STA plot_char_x

	LDY plot_y
	LDA div3_table, Y
	STA plot_char_y

	\\ Calculate screen address from coordinates
	LDY plot_char_y

	\\ Look up address of row from y coordinates
	CLC
	LDA mode7_row_addr_LO,Y
	ADC plot_char_x
	STA writeptr
	LDA mode7_row_addr_HI,Y
	ADC #0
	STA writeptr+1

	\\ Calculate x,y offset from coordinates
	LDA plot_x
	AND #1
	STA plot_x_offset

	\\ Need to select correct sprite data for x offset! ***

	\\ Then read off the data address LO & HI - mmph
	CLC
	LDA plot_ptr
	ADC #2
	STA load_sprite_byte0+1
	LDA plot_ptr+1
	ADC #0
	STA load_sprite_byte0+2

	\\ Pointer to byte 1
	CLC
	LDA load_sprite_byte0+1
	ADC plot_char_pitch
	STA load_sprite_byte1+1
	LDA load_sprite_byte0+2
	ADC #0
	STA load_sprite_byte1+2

	\\ Pointer to byte 2
	CLC
	LDA load_sprite_byte1+1
	ADC plot_char_pitch
	STA load_sprite_byte2+1
	LDA load_sprite_byte1+2
	ADC #0
	STA load_sprite_byte2+2

	\\ For each character row
	.y_loop

	LDX #0
	LDY #0
	.x_loop

	\\ Read three pixel rows at a time
	.load_sprite_byte0
	LDA starlin_data, X
	STA plot_linear_byte + 0

	.load_sprite_byte1
	LDA starlin_data+4, X				; +pitch
	STA plot_linear_byte + 1

	.load_sprite_byte2
	LDA starlin_data+8, X				; +pitch*2
	STA plot_linear_byte + 2

	\\ Might make more sense to arrange data in row-wise order?

	\\ First char - bits 7&6

	LDA #32
	STA plot_char_byte

	\\ First row - bits 7&6 of linear byte become 1&0 of char byte
	LDA plot_linear_byte + 0
	;AND #&C0						; not needed because of shift x 6
	LSR A: LSR A: LSR A: LSR A: LSR A: LSR A	; shift down 6
	ORA plot_char_byte
	STA plot_char_byte

	\\ Second row - bits 7&6 of linear byte become 3&2 of char byte
	LDA plot_linear_byte + 1
	AND #&C0
	LSR A: LSR A: LSR A: LSR A					; shift down 4
	ORA plot_char_byte
	STA plot_char_byte

	\\ Third row - bits 7&6 of linear byte become 6&4 of char byte
	LDA plot_linear_byte + 2
	AND #&80
	LSR A										; shift down 1
	ORA plot_char_byte
	STA plot_char_byte

	LDA plot_linear_byte + 2
	AND #&40
	LSR A:LSR A									; shift down 2
	ORA plot_char_byte
	STA plot_char_byte


	\\ Can finally plot one byte to screen!
	STA (writeptr), Y

	\\ Next char
	INY

	LDA #32
	STA plot_char_byte

	\\ Second char - bits 5&4

	\\ First row - bits 5&4 of linear byte become 1&0 of char byte
	LDA plot_linear_byte + 0
	AND #&30
	LSR A: LSR A: LSR A: LSR A					; shift down 4
	ORA plot_char_byte
	STA plot_char_byte

	\\ Second row - bits 5&4 of linear byte become 3&2 of char byte
	LDA plot_linear_byte + 1
	AND #&30
	LSR A: LSR A								; shift down 2
	ORA plot_char_byte
	STA plot_char_byte

	\\ Third row - bits 5&4 of linear byte become 6&4 of char byte
	LDA plot_linear_byte + 2
	AND #&20
	ASL A
	ORA plot_char_byte
	STA plot_char_byte

	LDA plot_linear_byte + 2
	AND #&10
	ORA plot_char_byte
	STA plot_char_byte

	\\ Can finally plot one byte to screen!
	STA (writeptr), Y

	\\ Next char
	INY

	LDA #32
	STA plot_char_byte

	\\ Third char - bits 3&2

	\\ First row - bits 3&2 of linear byte become 1&0 of char byte
	LDA plot_linear_byte + 0
	AND #&0C
	LSR A: LSR A								; shift down 2
	ORA plot_char_byte
	STA plot_char_byte

	\\ Second row - bits 3&2 of linear byte become 3&2 of char byte
	LDA plot_linear_byte + 1
	AND #&0C
	ORA plot_char_byte
	STA plot_char_byte

	\\ Third row - bits 3&2 of linear byte become 6&4 of char byte
	LDA plot_linear_byte + 2
	AND #&08
	ASL A: ASL A: ASL A							; shift up 3
	ORA plot_char_byte
	STA plot_char_byte

	LDA plot_linear_byte + 2
	AND #&04
	ASL A: ASL A								; shift up 2
	ORA plot_char_byte
	STA plot_char_byte

	\\ Can finally plot one byte to screen!
	STA (writeptr), Y

	\\ Next char
	INY

	LDA #32
	STA plot_char_byte

	\\ Fourth char - bits 1&0

	\\ First row - bits 1&0 of linear byte become 1&0 of char byte
	LDA plot_linear_byte + 0
	AND #&03
	ORA plot_char_byte
	STA plot_char_byte

	\\ Second row - bits 1&0 of linear byte become 3&2 of char byte
	LDA plot_linear_byte + 1
	AND #&03
	ASL A: ASL A								; shift up 2
	ORA plot_char_byte
	STA plot_char_byte

	\\ Third row - bits 1&0 of linear byte become 6&4 of char byte
	LDA plot_linear_byte + 2
	AND #&02
	ASL A: ASL A: ASL A: ASL A: ASL A			; shift up 5
	ORA plot_char_byte
	STA plot_char_byte

	LDA plot_linear_byte + 2
	AND #&01
	ASL A: ASL A: ASL A: ASL A					; shift up 4
	ORA plot_char_byte
	STA plot_char_byte

	\\ Can finally plot one byte to screen!
	STA (writeptr), Y

	\\ Next char
	INY

	\\ Next byte of sprite data
	INX
	CPX plot_char_w
	BCS next_row

	JMP x_loop
	
	\\ Next character row
	.next_row
	DEC plot_char_h
	BEQ return

	\\ Increment screen write pointer
	CLC
	LDA writeptr
	ADC #MODE7_char_width			; screen pitch
	STA writeptr
	LDA writeptr+1
	ADC #0
	STA writeptr+1
	
	\\ Increment sprite data read ptrs
	CLC
	LDA load_sprite_byte2+1
	ADC plot_char_pitch
	STA load_sprite_byte0+1
	LDA load_sprite_byte2+2
	ADC #0
	STA load_sprite_byte0+2

	\\ Pointer to byte 1
	CLC
	LDA load_sprite_byte0+1
	ADC plot_char_pitch
	STA load_sprite_byte1+1
	LDA load_sprite_byte0+2
	ADC #0
	STA load_sprite_byte1+2

	\\ Pointer to byte 2
	CLC
	LDA load_sprite_byte1+1
	ADC plot_char_pitch
	STA load_sprite_byte2+1
	LDA load_sprite_byte1+2
	ADC #0
	STA load_sprite_byte2+2

	JMP y_loop

	.return
	RTS
}

IF 0
.mode7_erase_sprite
{
	\\ Copy width and height in chars (bytes)
	LDY #0
	LDA (plot_ptr),Y
	STA plot_char_w
	INY
	LDA (plot_ptr),Y
	STA plot_char_h

	\\ Calculate screen address from coordinates

	\\ Look up address of row from y coordiante
	LDY plot_y
	LDA div3_table, Y
	TAY

	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1
	
	\\ Divide x coordinate by 2 for colum
	LDA plot_x
	LSR A							; x offset in carry

	\\ Add column to writeptr
	CLC
	ADC writeptr
	ADC #PLOT_origin_col
	STA store_screen_addr+1			; ** MODIFIES CODE
	LDA writeptr+1
	ADC #0
	STA store_screen_addr+2			; ** MODIFIES CODE

	\\ Plot loop

	\\ For each row
	LDY plot_char_h
	.y_loop

	\\ Plot all chars
	LDX #0
	LDA #0
	.x_loop
	.store_screen_addr
	STA &7C00,X						; ** SELF-MODIFIED CODE
	INX
	CPX plot_char_w
	BNE x_loop

	DEY
	BEQ done

	\\ Next line
	CLC
	LDA store_screen_addr+1
	ADC #MODE7_char_width
	STA store_screen_addr+1
	LDA store_screen_addr+2
	ADC #0
	STA store_screen_addr+2
	
	JMP y_loop
	.done

	.return
	RTS
}
ENDIF

\ ******************************************************************
\ *	Mirror FX
\ ******************************************************************

MIRROR_read_row0_addr = (MODE7_base_addr + ((MIRROR_read_row-0) * MODE7_char_width))
MIRROR_read_row1_addr = (MODE7_base_addr + ((MIRROR_read_row-1) * MODE7_char_width))
MIRROR_read_row2_addr = (MODE7_base_addr + ((MIRROR_read_row-2) * MODE7_char_width))
MIRROR_read_row3_addr = (MODE7_base_addr + ((MIRROR_read_row-3) * MODE7_char_width))
MIRROR_read_row4_addr = (MODE7_base_addr + ((MIRROR_read_row-4) * MODE7_char_width))
MIRROR_read_row5_addr = (MODE7_base_addr + ((MIRROR_read_row-5) * MODE7_char_width))
MIRROR_read_row6_addr = (MODE7_base_addr + ((MIRROR_read_row-6) * MODE7_char_width))
MIRROR_read_row7_addr = (MODE7_base_addr + ((MIRROR_read_row-7) * MODE7_char_width))
MIRROR_read_row8_addr = (MODE7_base_addr + ((MIRROR_read_row-8) * MODE7_char_width))

MIRROR_write_row0_addr = (MODE7_base_addr + ((MIRROR_top_row+0) * MODE7_char_width))
MIRROR_write_row1_addr = (MODE7_base_addr + ((MIRROR_top_row+1) * MODE7_char_width))
MIRROR_write_row2_addr = (MODE7_base_addr + ((MIRROR_top_row+2) * MODE7_char_width))

.mode7_mirror_fx
{
	LDX #PLOT_origin_col
	.loop0
	LDA MIRROR_read_row0_addr,X
	AND #&3
	STA mirror_byte
	LDA MIRROR_read_row1_addr,X
	AND #&3
	ASL A: ASL A				; bits 0&1 become 2&3
	ORA mirror_byte
	STA mirror_byte
	LDA MIRROR_read_row2_addr,X
	AND #&3
	ASL A: ASL A
	ASL A: ASL A				; bits 0&1 become 4&5
	STA mirror_bit
	AND #&20					; take bit 5 and make it bit 6
	ASL A
	ORA #&20
	ORA mirror_bit
	ORA mirror_byte
	STA MIRROR_write_row0_addr,X
	INX
	CPX #MODE7_char_width
	BCC loop0

	LDX #PLOT_origin_col
	.loop1
	LDA MIRROR_read_row3_addr,X
	AND #&3
	STA mirror_byte
	LDA MIRROR_read_row4_addr,X
	AND #&3
	ASL A: ASL A				; bits 0&1 become 2&3
	ORA mirror_byte
	STA mirror_byte
	LDA MIRROR_read_row5_addr,X
	AND #&3
	ASL A: ASL A
	ASL A: ASL A				; bits 0&1 become 4&5
	STA mirror_bit
	AND #&20					; take bit 5 and make it bit 6
	ASL A
	ORA #&20
	ORA mirror_bit
	ORA mirror_byte
	STA MIRROR_write_row1_addr,X
	INX
	CPX #MODE7_char_width
	BCC loop1

	LDX #PLOT_origin_col
	.loop2
	LDA MIRROR_read_row6_addr,X
	AND #&3
	STA mirror_byte
	LDA MIRROR_read_row7_addr,X
	AND #&3
	ASL A: ASL A				; bits 0&1 become 2&3
	ORA mirror_byte
	STA mirror_byte
	LDA MIRROR_read_row8_addr,X
	AND #&3
	ASL A: ASL A
	ASL A: ASL A				; bits 0&1 become 4&5
	STA mirror_bit
	AND #&20					; take bit 5 and make it bit 6
	ASL A
	ORA #&20
	ORA mirror_bit
	ORA mirror_byte
	STA MIRROR_write_row2_addr,X
	INX
	CPX #MODE7_char_width
	BCC loop2

	.return
	RTS
}


\ ******************************************************************
\ *	Raster FX
\ ******************************************************************

RASTER_centre_row = 11
RASTER_wave_rows = 6
RASTER_table_inc = 8
RASTER_row0_addr = (MODE7_base_addr + ((RASTER_centre_row-6) * MODE7_char_width))
RASTER_row1_addr = (MODE7_base_addr + ((RASTER_centre_row-5) * MODE7_char_width))
RASTER_row2_addr = (MODE7_base_addr + ((RASTER_centre_row-4) * MODE7_char_width))
RASTER_row3_addr = (MODE7_base_addr + ((RASTER_centre_row-3) * MODE7_char_width))
RASTER_row4_addr = (MODE7_base_addr + ((RASTER_centre_row-2) * MODE7_char_width))
RASTER_row5_addr = (MODE7_base_addr + ((RASTER_centre_row-1) * MODE7_char_width))
RASTER_row6_addr = (MODE7_base_addr + ((RASTER_centre_row-0) * MODE7_char_width))
RASTER_row7_addr = (MODE7_base_addr + ((RASTER_centre_row+1) * MODE7_char_width))
RASTER_row8_addr = (MODE7_base_addr + ((RASTER_centre_row+2) * MODE7_char_width))
RASTER_row9_addr = (MODE7_base_addr + ((RASTER_centre_row+3) * MODE7_char_width))
RASTER_row10_addr = (MODE7_base_addr + ((RASTER_centre_row+4) * MODE7_char_width))
RASTER_row11_addr = (MODE7_base_addr + ((RASTER_centre_row+5) * MODE7_char_width))
RASTER_row12_addr = (MODE7_base_addr + ((RASTER_centre_row+6) * MODE7_char_width))

.mode7_raster_fx
{
	LDA #MODE7_black_bg
	STA RASTER_row0_addr+1
	STA RASTER_row1_addr+1
	STA RASTER_row2_addr+1
	STA RASTER_row3_addr+1
	STA RASTER_row4_addr+1
	STA RASTER_row5_addr+1
	STA RASTER_row6_addr+1
	STA RASTER_row7_addr+1
	STA RASTER_row8_addr+1
	STA RASTER_row9_addr+1
	STA RASTER_row10_addr+1
	STA RASTER_row11_addr+1
	STA RASTER_row12_addr+1

	LDX raster_idx
	LDA raster_y_table, X
	TAY
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1
	LDY #0
	LDA #MODE7_graphic_black + 1
	STA (writeptr),Y
	INY
	LDA #MODE7_new_bg
	STA (writeptr),Y

	TXA:CLC:ADC #RASTER_table_inc:TAX
	LDA raster_y_table, X
	TAY
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1
	LDY #0
	LDA #MODE7_graphic_black + 2
	STA (writeptr),Y
	INY
	LDA #MODE7_new_bg
	STA (writeptr),Y

	TXA:CLC:ADC #RASTER_table_inc:TAX
	LDA raster_y_table, X
	TAY
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1
	LDY #0
	LDA #MODE7_graphic_black + 3
	STA (writeptr),Y
	INY
	LDA #MODE7_new_bg
	STA (writeptr),Y

	TXA:CLC:ADC #RASTER_table_inc:TAX
	LDA raster_y_table, X
	TAY
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1
	LDY #0
	LDA #MODE7_graphic_black + 4
	STA (writeptr),Y
	INY
	LDA #MODE7_new_bg
	STA (writeptr),Y

	TXA:CLC:ADC #RASTER_table_inc:TAX
	LDA raster_y_table, X
	TAY
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1
	LDY #0
	LDA #MODE7_graphic_black + 5
	STA (writeptr),Y
	INY
	LDA #MODE7_new_bg
	STA (writeptr),Y

	TXA:CLC:ADC #RASTER_table_inc:TAX
	LDA raster_y_table, X
	TAY
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1
	LDY #0
	LDA #MODE7_graphic_black + 6
	STA (writeptr),Y
	INY
	LDA #MODE7_new_bg
	STA (writeptr),Y

	INC raster_idx
	INC raster_idx

	.return
	RTS
}


\ ******************************************************************
\ *	Starfield FX
\ ******************************************************************

STARS_row0_addr = (MODE7_base_addr + ((0) * MODE7_char_width))

.mode7_starfield_init
{
	LDA #0

	LDY #STARS_num-1
	.loop
	STA stars_table_byte,Y
	DEY
	BPL loop

	.return
	RTS
}

.mode7_starfield_fx
{
	LDA #LO(MODE7_base_addr + PLOT_origin_col)
	STA writeptr
	LDA #HI(MODE7_base_addr + PLOT_origin_col)
	STA writeptr+1

	LDX #0
	.loop

	\\ Erase old star
	LDA stars_table_byte,X
	CMP #32
	BNE no_erase
	LDA stars_table_x,X
	LSR A:LSR A:TAY:LDA #32
	STA (writeptr),Y

	.no_erase
	\\ Update star x position based on speed & wrap
	CLC
	LDA stars_table_x,X
	ADC stars_table_speed,X
	CMP #MODE7_texel_width*2
	BCC no_wrap
	SBC #MODE7_texel_width*2
	.no_wrap
	STA stars_table_x,X

	\\ Calculate x char
	LSR A:LSR A:TAY

	\\ Is there something there already?
	LDA (writeptr), Y
	STA stars_table_byte,X
	CMP #32
	BNE skip_write

	\\ Plot our star
	LDA stars_table_x,X
	LSR A
	AND #&1						; odd or even
	CLC
	ADC #33						; 1 or 2 OR 32
	STA (writeptr), Y			; reuses Y as x char from above

	.skip_write

	\\ Next star
	INX
	CPX #STARS_num
	BCS return

	\\ Next row
	CLC
	LDA writeptr
	ADC #MODE7_char_width
	STA writeptr
	BCC no_carry
	INC writeptr+1
	.no_carry
	JMP loop

	.return
	RTS
}

\ ******************************************************************
\ *	Look up tables
\ ******************************************************************

.mode7_row_addr_LO
FOR n, 0, MODE7_char_height-1, 1
EQUB LO(MODE7_base_addr + n * MODE7_char_width)
NEXT

.mode7_row_addr_HI
FOR n, 0, MODE7_char_height-1, 1
EQUB HI(MODE7_base_addr + n * MODE7_char_width)
NEXT

.mod3_table					; wasteful to have all 256 entries but safer for now
FOR n, 0, 255, 1
IF n < 128
	EQUB (n MOD 3)
ELSE
	EQUB (3-((256-n) MOD 3)) MOD 3	; 255=-1 -> 2, 254=-2 -> 1, 253=-3 -> 0, 252=-4 -> 2 etc.
ENDIF
NEXT

.div3_table					; wasteful to have all 256 entries but safer for now
FOR n, 0, 255, 1
	EQUB (n DIV 3)
NEXT

.raster_y_table				; don't need 256 entries but easier for now
FOR n, 0, 255, 1
	EQUB RASTER_centre_row + RASTER_wave_rows * SIN(PI * n / 128)
NEXT

.stars_table_x
FOR n, 0, STARS_num, 1
	EQUB RND(MODE7_texel_width * 2)
NEXT

.stars_table_speed
FOR n, 0, STARS_num, 1
	EQUB 1+RND(3)
NEXT


\ ******************************************************************
\ *	Included data
\ ******************************************************************

;INCLUDE "starhole.6502"
INCLUDE "starlin.6502"

\ ******************************************************************
\ *	End address to be saved
\ ******************************************************************

.end


\ ******************************************************************
\ *	Space reserved for runtime buffers not preinitialised
\ ******************************************************************

.stars_table_byte
SKIP STARS_num

ALIGN &100

\ ******************************************************************
\ *	Save the code
\ ******************************************************************

SAVE "M7Plot", start, end
