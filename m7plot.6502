\ ******************************************************************
\ * TeleTexel v1
\ * Music visualiser in MODE 7
\ * Treat MODE 7 as a 76 x 75 pixel canvas (aka teletexels)
\ ******************************************************************


\ ******************************************************************
\ *	Define OS entries (could be INCLUDE bbc_os.h)
\ ******************************************************************

oswrch = &FFEE
osasci = &FFE3
osbyte = &FFF4
osword = &FFF1
EVENTV = &0220

INKEY_esc = 112
INKEY_w = 33
INKEY_s = 81
INKEY_a = 65
INKEY_d = 50

SEI_OP = $78
CLI_OP = $58
NOP_OP = $ea

\ ******************************************************************
\ *	Define debug flags (prefer DEBUG_* naming?)
\ ******************************************************************


\ ******************************************************************
\ *	Define macros (prefer MACRO_* naming?)
\ ******************************************************************

\ ******************************************************************
\ *	Define global constants
\ ******************************************************************

MODE7_base_addr = &7C00
MODE7_char_width = 40
MODE7_char_height = 25

MODE7_alpha_black = 128
MODE7_graphic_black = 144
MODE7_contiguous = 153
MODE7_separated = 154
MODE7_black_bg = 156
MODE7_new_bg = 157

PLOT_origin_col = 4				; skip first 4 coloumns (col + newbg + col + sep)
MODE7_texel_width = (MODE7_char_width - PLOT_origin_col) * 2
MODE7_texel_height = MODE7_char_height * 3


MIRROR_bottom_row = 24
MIRROR_top_row = 22
MIRROR_read_row = MIRROR_top_row - 1

STARS_num = 22


\ ******************************************************************
\ *	Define fast (zero page) runtime variables
\ ******************************************************************

ORG &7B
GUARD &A0

.writeptr				SKIP 2
.readptr				SKIP 2

.test_x					SKIP 1
.test_y					SKIP 1

.plot_ptr				SKIP 2			; ptr to sprite data
.plot_x					SKIP 1			; x coordinate in pixels
.plot_y					SKIP 1			; y coordinate in pixels
.plot_char_w			SKIP 1			; sprite width in chars
.plot_char_h			SKIP 1			; sprite width in chars
.plot_x_offset			SKIP 1			; sprite offset x
.plot_y_offset			SKIP 1			; sprite offset y
.plot_char_x			SKIP 1			; x position in chars absolute
.plot_char_y			SKIP 1			; y position in chars absolute
.plot_char_pitch		SKIP 1			; pitch of sprite data in chars
.plot_diff_x			SKIP 1
.plot_diff_y			SKIP 1

.plot_half_byte			SKIP 1
.plot_half_x			SKIP 1

.mirror_byte			SKIP 1
.mirror_bit				SKIP 1

.raster_idx				SKIP 1

\ ******************************************************************
\ *	Start address to be saved
\ ******************************************************************

ORG &1900	      					; code origin (like P%=&2000)
GUARD &7C00							; ensure code size doesn't hit start of screen memory

.start

\ ******************************************************************
\ *	Code entry
\ ******************************************************************

\ ******************************************************************
\ *	Main loop sequencing tick & draw code
\ ******************************************************************

.main
{
	\\ Set MODE 7 for memory
	LDA #22: JSR oswrch
	LDA #7: JSR oswrch
	\\ Turn off cursor!

	JSR teletexel_init
	JSR mode7_starfield_init

	LDA #128
	STA test_x
	LDA #129
	STA test_y
	LDA #0
	STA raster_idx

	.loop

	\\ Wait for vsync
	LDA #19
	JSR osbyte

;	LDA test_x
;	STA plot_x
;	LDA test_y
;	STA plot_y
;	LDA #LO(starhole)
;	STA plot_ptr
;	LDA #HI(starhole)
;	STA plot_ptr+1
;	JSR mode7_erase_sprite

	\\ Check for Escape key
	{
		LDA #121
		LDX #0
		JSR osbyte
		CPX #INKEY_esc
		BEQ exit

		CPX #INKEY_w
		BNE not_w
		DEC test_y
		.not_w
		CPX #INKEY_s
		BNE not_s
		INC test_y
		.not_s
		CPX #INKEY_a
		BNE not_a
		DEC test_x
		.not_a
		CPX #INKEY_d
		BNE not_d
		INC test_x
		.not_d
	}

	LDA test_x
	STA plot_x
	LDA test_y
	STA plot_y
	LDA #LO(starhalf)
	STA plot_ptr
	LDA #HI(starhalf)
	STA plot_ptr+1

	JSR mode7_plot_half

;	JSR mode7_raster_fx
	JSR mode7_starfield_fx
	JSR mode7_mirror_fx

	JMP loop

	\\ Until we finish
	.exit

	RTS
}

.teletexel_init
{
	LDX #0

	.loop
	LDA mode7_row_addr_LO,X
	STA writeptr
	LDA mode7_row_addr_HI,X
	STA writeptr+1
	
	LDY #0

	CPX #MIRROR_top_row
	BCC not_mirror
	LDA #MODE7_graphic_black + 4
	STA (writeptr),Y

	INY
	LDA #MODE7_new_bg
	STA (writeptr),Y
	BNE done_mirror

	.not_mirror
	LDA #MODE7_graphic_black + 7
	STA (writeptr),Y

	INY
	LDA #MODE7_black_bg
	STA (writeptr),Y
	
	.done_mirror
	INY
	LDA #MODE7_contiguous
	STA (writeptr),Y

	INY
	LDA #MODE7_graphic_black + 7
	STA (writeptr),Y

	INX
	CPX #MODE7_char_height
	BCC loop

	.return
	RTS
}


\ ******************************************************************
\ *	Sprite plot routine
\ * Want the interface to be something like:
\ * Sprite data address = plot_ptr
\ * X coordinate, Y coordinate = plot_x, plot_y
\ ******************************************************************

.mode7_plot_sprite
{
	\\ Zero any temporary variables
	LDY #0
	STY plot_diff_x
	STY plot_diff_y

	\\ Copy width and height in chars (bytes)
	LDA (plot_ptr),Y
	STA plot_char_w
	STA plot_char_pitch				; store pitch
	INY
	LDA (plot_ptr),Y
	STA plot_char_h

	\\ Calculate x,y offset from coordinates
	LDA plot_x
	AND #1
	STA plot_x_offset

	\\ Calculate absolute x,y character pos from coordinates
	LDA plot_x
	BPL no_clip_left

	\\ x < 0
	\\ Make positive
	EOR #&FF						; flip bits + 1
	CLC
	ADC #2							; add 1 as as need to correctly round to chars
	LSR A							; div 2
	STA plot_diff_x					; this is the diff to clip in chars

	\\ Reduce width by diff			
	SEC
	LDA plot_char_w
	SBC plot_diff_x					; could just add this
	BPL visible_left				; w - x < 0 so plot position is off screen

	.jump_not_visible
	JMP not_visible					; stupid branch range
	
	.visible_left
	STA plot_char_w

	\\ Reset x
	LDA #0							; x=0

	.no_clip_left
	LSR A							; relative
	CLC
	ADC #PLOT_origin_col			; make absolute
	STA plot_char_x

	\\ Check if not visible
	CMP #MODE7_char_width
	BCS jump_not_visible			; x > 40 so plot position is off screen

	\\ Now test for right clip by adding width
	CLC
	ADC plot_char_w
	CMP #MODE7_char_width
	BCC no_clip_right

	\\ Is over width of screen
	; Carry set
	LDA #MODE7_char_width
	SBC plot_char_x
	STA plot_char_w					; clip width = 40 - x

	.no_clip_right

	\\ Look up y coordinate
	LDY plot_y

	LDA mod3_table, Y
	STA plot_y_offset

	\\ y < 0?
	TYA
	BPL no_clip_top

	\\ Make positive

	EOR #&FF					; flip the bits +1 then -1
	TAY

	CLC
	LDA div3_table, Y			; char row = y DIV 3
	ADC #1						; when negative need one more char row`
	STA plot_diff_y

	SEC
	LDA plot_char_h
	SBC plot_diff_y				; subtract clipped character rows from height
	STA plot_char_h

	BEQ jump_not_visible		; if h <= 0 then not visible
	BMI jump_not_visible

	LDY #0

	.no_clip_top
	LDA div3_table, Y
	STA plot_char_y

	\\ Check if not visible off bottom
	CMP #MODE7_char_height
	BCS jump_not_visible			; y > 25 so plot position is off screen

	\\ Now test for bottom clip by adding height
	CLC
	ADC plot_char_h
	CMP #MODE7_char_height
	BCC no_clip_bottom

	\\ Is over height of screen
	; Carry set
	LDA #MODE7_char_height
	SBC plot_char_y
	STA plot_char_h					; clip height = 25 - y

	.no_clip_bottom

	\\ Calculate screen address from coordinates
	LDY plot_char_y

	\\ Look up address of row from y coordinates
	CLC
	LDA mode7_row_addr_LO,Y
	ADC plot_char_x
	STA store_screen_addr+1			; ** MODIFIES CODE
	LDA mode7_row_addr_HI,Y
	ADC #0
	STA store_screen_addr+2			; ** MODIFIES CODE

	\\ Locate sprite data = x_offset*6 + y_offset*2 - ick
	CLC
	LDA plot_x_offset
	BEQ x_offset_zero
	LDA #6							; 3x y offsets * 2x bytes
	.x_offset_zero
	ADC plot_y_offset
	ADC plot_y_offset
	ADC #2							; skip w & h bytes

	TAY

	\\ Then read off the data address LO & HI - mmph
	CLC
	LDA (plot_ptr),Y
	ADC plot_diff_x					; offset into sprite data for clip
	STA load_sprite_data+1
	INY
	LDA (plot_ptr),Y
	STA load_sprite_data+2

	\\ If we're clipped off the top we need to start from inside the sprite data
	{
		LDY plot_diff_y
		.loop
		BEQ done
		CLC
		LDA load_sprite_data+1
		ADC plot_char_pitch
		STA load_sprite_data+1
		LDA load_sprite_data+2
		ADC #0
		STA load_sprite_data+2
		DEY
		BNE loop
		.done
	}

	\\ Plot loop

	\\ For each row
	LDY plot_char_h
	.y_loop

	\\ Plot all chars
	LDX #0							; start at left clip
	.x_loop
	CPX plot_char_w
	BCS done_x_loop
	.load_sprite_data
	LDA end,X						; ** SELF-MODIFIED CODE
	.store_screen_addr
	STA &7C00,X						; ** SELF-MODIFIED CODE
	INX
	JMP x_loop

	.done_x_loop
	DEY
	BEQ done_y_loop

	\\ Next line
	CLC
	LDA store_screen_addr+1
	ADC #MODE7_char_width			; screen pitch
	STA store_screen_addr+1
	LDA store_screen_addr+2
	ADC #0
	STA store_screen_addr+2
	
	\\ Next data - gah this is continuous
	CLC
	LDA load_sprite_data+1
	ADC plot_char_pitch				; sprite pitch
	STA load_sprite_data+1
	LDA load_sprite_data+2
	ADC #0
	STA load_sprite_data+2

	JMP y_loop
	.done_y_loop
	.not_visible

	.return
	RTS
}

.mode7_plot_half
{
	\\ Zero any temporary variables
	LDY #0
	STY plot_diff_x

	\\ Copy width and height in chars (bytes)
	LDA (plot_ptr),Y
	STA plot_char_pitch						; store pitch
	SEC
	SBC #1									; w = pitch - 1
	STA plot_char_w
	INY
	LDA (plot_ptr),Y
	STA plot_char_h

	\\ X calcs

	\\ Check X against right edge
	LDA plot_x
	BCC is_visible_right
	
	.not_visible
	RTS

	.is_visible_right
	\\ Check X against left edge
	BCS no_left_clip

	\\ Check X+W against left edge
	ADC plot_char_w
	BCC not_visible

	\\ Clip left side
	\\ Don't need to set width as this is actually an index check
	\\ But do need to specify index to look up into sprite data
	SEC
	SBC plot_x
	STA plot_diff_x

	\\ Set X to left edge
	STA plot_x

	.no_left_clip
	\\ Check X+W against right edge
	CLC
	ADC plot_char_w
	BCC no_right_clip

	\\ Set width to right edge
	\\ W = right edge - X
	SBC plot_x
	STA plot_char_w

	.no_right_clip

	\\ Character pos X
	SEC
	LDA plot_x
	LSR A
	STA plot_char_x

	\\ Need sprite data here because Y clip will update sprite pointer

	\\ Read address start of sprite data - can get caller to set this?
	CLC
	LDA plot_ptr
	ADC #2
	STA readptr
	LDA plot_ptr+1
	ADC #0
	STA readptr+1

	\\ Convert texel coordinates to chars and clip in this space

	\\ Y calcs
	LDY plot_y
	LDA mod3_table, Y
	STA plot_y_offset

	LDA div3_table, Y
	STA plot_char_y

	\\ Check char Y against bottom edge	
	BCS not_visible

	\\ Check char Y against top edge
	BCS no_clip_top

	\\ Check Y + H against top edge
	ADC plot_char_h
	BCC not_visible

	\\ Clip against top edge
	SEC
	SBC plot_char_y
	TAX

	\\ Need to update start index into sprite data
	.increment_top_row
	{
		CLC
		LDA readptr
		ADC plot_char_pitch				; CONST!
		STA readptr
		BCC no_carry
		INC readptr+1
		.no_carry
	}

	\\ And reduce number of rows left to actually plot
	DEC plot_char_h

	\\ H -= top edge - Y
	DEX
	BNE increment_top_row

	\\ Set Y to top edge
	STA plot_char_y

	.no_clip_top
	\\ Check Y + H against bottom edge
	ADC plot_char_h
	BCC no_bottom_clip
	
	\\ Set height to bottom edge
	\\ H = bottom edge - Y
	SBC plot_char_y
	STA plot_char_h

	.no_bottom_clip

	\\ Calculate screen address from coordinates
	SEC
	LDA plot_char_y
	TAY

	\\ Look up address of row from y coordinates
	CLC
	LDA mode7_row_addr_LO, Y
	ADC plot_char_x
	STA screen_write_addr+1
	LDA mode7_row_addr_HI, Y
	ADC #0
	STA screen_write_addr+2

	\\ Set up left & right side table indices - could pre-calc the shift
	LDA plot_y_offset
	ASL A: ASL A: ASL A: ASL A: ASL A: ASL A
	STA plot_half_left+1				; ** MODIFIES CODE		

	ORA #&20
	STA plot_half_right+1				; ** MODIFIES CODE

	\\ Plot loop
	.y_loop
	LDY plot_diff_x						; index into sprite data

	LDX #0						
	STX plot_half_x						; index across screen row
	STX plot_half_byte

	; BEQ start_right_half				; when plot_x & 1 
	; BNE start_right_half				; when !plot_x & 1
	\\ X offset
	LDA plot_x							; CONST!
	AND #1
	BNE start_right_half

	.x_loop
	STX plot_half_x

	\\ Get left column of sprite data
	LDA (readptr), Y

	\\ Turn this into MODE 7 gfx code for left column
	.plot_half_left
	ORA #&00         					; where left_header = yy0 00000 - ** SELF-MODIFIED CODE
	TAX
	LDA half_column_lookup, X

	\\ Store it
	STA plot_half_byte

	\\ Get right column of sprite data
	INY

	.start_right_half
	LDA (readptr), Y

	\\ Turn this into MODE 7 gfx code for right column
	.plot_half_right
	ORA #&20			        		; where right_header = yy1 00000 - ** SELF-MODIFIED CODE
	TAX
	LDA half_column_lookup, X

	\\ Combine it with left column
	ORA plot_half_byte       			; mask in other half

	\\ Write combined columns to screen	
	LDX plot_half_x
	.screen_write_addr
	STA &7C00, X						; write to screen - ** SELF-MODIFIED CODE
	INX

	\\ Have we reached end of columns?
	INY
	CPY plot_char_w						; CONST!
	BCC x_loop

	\\ Have we reached end of rows?
	DEC plot_char_h
	BEQ return

	\\ Next line on screen
	{
		CLC
		LDA screen_write_addr+1
		ADC #MODE7_char_width			; screen pitch
		STA screen_write_addr+1
		BCC no_carry
		INC screen_write_addr+2
		.no_carry
	}

	\\ Next line of sprite data - is contiguous but > 256 bytes 
	{
		CLC
		LDA readptr
		ADC plot_char_pitch				; CONST!
		STA readptr
		BCC no_carry
		INC readptr+1
		.no_carry
	}
	
	JMP y_loop	

	.return
	RTS
}

IF 0
.mode7_erase_sprite
{
	\\ Copy width and height in chars (bytes)
	LDY #0
	LDA (plot_ptr),Y
	STA plot_char_w
	INY
	LDA (plot_ptr),Y
	STA plot_char_h

	\\ Calculate screen address from coordinates

	\\ Look up address of row from y coordiante
	LDY plot_y
	LDA div3_table, Y
	TAY

	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1
	
	\\ Divide x coordinate by 2 for colum
	LDA plot_x
	LSR A							; x offset in carry

	\\ Add column to writeptr
	CLC
	ADC writeptr
	ADC #PLOT_origin_col
	STA store_screen_addr+1			; ** MODIFIES CODE
	LDA writeptr+1
	ADC #0
	STA store_screen_addr+2			; ** MODIFIES CODE

	\\ Plot loop

	\\ For each row
	LDY plot_char_h
	.y_loop

	\\ Plot all chars
	LDX #0
	LDA #0
	.x_loop
	.store_screen_addr
	STA &7C00,X						; ** SELF-MODIFIED CODE
	INX
	CPX plot_char_w
	BNE x_loop

	DEY
	BEQ done

	\\ Next line
	CLC
	LDA store_screen_addr+1
	ADC #MODE7_char_width
	STA store_screen_addr+1
	LDA store_screen_addr+2
	ADC #0
	STA store_screen_addr+2
	
	JMP y_loop
	.done

	.return
	RTS
}
ENDIF

\ ******************************************************************
\ *	Mirror FX
\ ******************************************************************

MIRROR_read_row0_addr = (MODE7_base_addr + ((MIRROR_read_row-0) * MODE7_char_width))
MIRROR_read_row1_addr = (MODE7_base_addr + ((MIRROR_read_row-1) * MODE7_char_width))
MIRROR_read_row2_addr = (MODE7_base_addr + ((MIRROR_read_row-2) * MODE7_char_width))
MIRROR_read_row3_addr = (MODE7_base_addr + ((MIRROR_read_row-3) * MODE7_char_width))
MIRROR_read_row4_addr = (MODE7_base_addr + ((MIRROR_read_row-4) * MODE7_char_width))
MIRROR_read_row5_addr = (MODE7_base_addr + ((MIRROR_read_row-5) * MODE7_char_width))
MIRROR_read_row6_addr = (MODE7_base_addr + ((MIRROR_read_row-6) * MODE7_char_width))
MIRROR_read_row7_addr = (MODE7_base_addr + ((MIRROR_read_row-7) * MODE7_char_width))
MIRROR_read_row8_addr = (MODE7_base_addr + ((MIRROR_read_row-8) * MODE7_char_width))

MIRROR_write_row0_addr = (MODE7_base_addr + ((MIRROR_top_row+0) * MODE7_char_width))
MIRROR_write_row1_addr = (MODE7_base_addr + ((MIRROR_top_row+1) * MODE7_char_width))
MIRROR_write_row2_addr = (MODE7_base_addr + ((MIRROR_top_row+2) * MODE7_char_width))

.mode7_mirror_fx
{
	LDX #PLOT_origin_col
	.loop0
	LDA MIRROR_read_row0_addr,X
	AND #&3
	STA mirror_byte
	LDA MIRROR_read_row1_addr,X
	AND #&3
	ASL A: ASL A				; bits 0&1 become 2&3
	ORA mirror_byte
	STA mirror_byte
	LDA MIRROR_read_row2_addr,X
	AND #&3
	ASL A: ASL A
	ASL A: ASL A				; bits 0&1 become 4&5
	STA mirror_bit
	AND #&20					; take bit 5 and make it bit 6
	ASL A
	ORA #&20
	ORA mirror_bit
	ORA mirror_byte
	STA MIRROR_write_row0_addr,X
	INX
	CPX #MODE7_char_width
	BCC loop0

	LDX #PLOT_origin_col
	.loop1
	LDA MIRROR_read_row3_addr,X
	AND #&3
	STA mirror_byte
	LDA MIRROR_read_row4_addr,X
	AND #&3
	ASL A: ASL A				; bits 0&1 become 2&3
	ORA mirror_byte
	STA mirror_byte
	LDA MIRROR_read_row5_addr,X
	AND #&3
	ASL A: ASL A
	ASL A: ASL A				; bits 0&1 become 4&5
	STA mirror_bit
	AND #&20					; take bit 5 and make it bit 6
	ASL A
	ORA #&20
	ORA mirror_bit
	ORA mirror_byte
	STA MIRROR_write_row1_addr,X
	INX
	CPX #MODE7_char_width
	BCC loop1

	LDX #PLOT_origin_col
	.loop2
	LDA MIRROR_read_row6_addr,X
	AND #&3
	STA mirror_byte
	LDA MIRROR_read_row7_addr,X
	AND #&3
	ASL A: ASL A				; bits 0&1 become 2&3
	ORA mirror_byte
	STA mirror_byte
	LDA MIRROR_read_row8_addr,X
	AND #&3
	ASL A: ASL A
	ASL A: ASL A				; bits 0&1 become 4&5
	STA mirror_bit
	AND #&20					; take bit 5 and make it bit 6
	ASL A
	ORA #&20
	ORA mirror_bit
	ORA mirror_byte
	STA MIRROR_write_row2_addr,X
	INX
	CPX #MODE7_char_width
	BCC loop2

	.return
	RTS
}


\ ******************************************************************
\ *	Raster FX
\ ******************************************************************

RASTER_centre_row = 11
RASTER_wave_rows = 6
RASTER_table_inc = 8
RASTER_row0_addr = (MODE7_base_addr + ((RASTER_centre_row-6) * MODE7_char_width))
RASTER_row1_addr = (MODE7_base_addr + ((RASTER_centre_row-5) * MODE7_char_width))
RASTER_row2_addr = (MODE7_base_addr + ((RASTER_centre_row-4) * MODE7_char_width))
RASTER_row3_addr = (MODE7_base_addr + ((RASTER_centre_row-3) * MODE7_char_width))
RASTER_row4_addr = (MODE7_base_addr + ((RASTER_centre_row-2) * MODE7_char_width))
RASTER_row5_addr = (MODE7_base_addr + ((RASTER_centre_row-1) * MODE7_char_width))
RASTER_row6_addr = (MODE7_base_addr + ((RASTER_centre_row-0) * MODE7_char_width))
RASTER_row7_addr = (MODE7_base_addr + ((RASTER_centre_row+1) * MODE7_char_width))
RASTER_row8_addr = (MODE7_base_addr + ((RASTER_centre_row+2) * MODE7_char_width))
RASTER_row9_addr = (MODE7_base_addr + ((RASTER_centre_row+3) * MODE7_char_width))
RASTER_row10_addr = (MODE7_base_addr + ((RASTER_centre_row+4) * MODE7_char_width))
RASTER_row11_addr = (MODE7_base_addr + ((RASTER_centre_row+5) * MODE7_char_width))
RASTER_row12_addr = (MODE7_base_addr + ((RASTER_centre_row+6) * MODE7_char_width))

.mode7_raster_fx
{
	LDA #MODE7_black_bg
	STA RASTER_row0_addr+1
	STA RASTER_row1_addr+1
	STA RASTER_row2_addr+1
	STA RASTER_row3_addr+1
	STA RASTER_row4_addr+1
	STA RASTER_row5_addr+1
	STA RASTER_row6_addr+1
	STA RASTER_row7_addr+1
	STA RASTER_row8_addr+1
	STA RASTER_row9_addr+1
	STA RASTER_row10_addr+1
	STA RASTER_row11_addr+1
	STA RASTER_row12_addr+1

	LDX raster_idx
	LDA raster_y_table, X
	TAY
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1
	LDY #0
	LDA #MODE7_graphic_black + 1
	STA (writeptr),Y
	INY
	LDA #MODE7_new_bg
	STA (writeptr),Y

	TXA:CLC:ADC #RASTER_table_inc:TAX
	LDA raster_y_table, X
	TAY
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1
	LDY #0
	LDA #MODE7_graphic_black + 2
	STA (writeptr),Y
	INY
	LDA #MODE7_new_bg
	STA (writeptr),Y

	TXA:CLC:ADC #RASTER_table_inc:TAX
	LDA raster_y_table, X
	TAY
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1
	LDY #0
	LDA #MODE7_graphic_black + 3
	STA (writeptr),Y
	INY
	LDA #MODE7_new_bg
	STA (writeptr),Y

	TXA:CLC:ADC #RASTER_table_inc:TAX
	LDA raster_y_table, X
	TAY
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1
	LDY #0
	LDA #MODE7_graphic_black + 4
	STA (writeptr),Y
	INY
	LDA #MODE7_new_bg
	STA (writeptr),Y

	TXA:CLC:ADC #RASTER_table_inc:TAX
	LDA raster_y_table, X
	TAY
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1
	LDY #0
	LDA #MODE7_graphic_black + 5
	STA (writeptr),Y
	INY
	LDA #MODE7_new_bg
	STA (writeptr),Y

	TXA:CLC:ADC #RASTER_table_inc:TAX
	LDA raster_y_table, X
	TAY
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1
	LDY #0
	LDA #MODE7_graphic_black + 6
	STA (writeptr),Y
	INY
	LDA #MODE7_new_bg
	STA (writeptr),Y

	INC raster_idx
	INC raster_idx

	.return
	RTS
}


\ ******************************************************************
\ *	Starfield FX
\ ******************************************************************

STARS_row0_addr = (MODE7_base_addr + ((0) * MODE7_char_width))

.mode7_starfield_init
{
	LDA #0

	LDY #STARS_num-1
	.loop
	STA stars_table_byte,Y
	DEY
	BPL loop

	.return
	RTS
}

.mode7_starfield_fx
{
	LDA #LO(MODE7_base_addr + PLOT_origin_col)
	STA writeptr
	LDA #HI(MODE7_base_addr + PLOT_origin_col)
	STA writeptr+1

	LDX #0
	.loop

	\\ Erase old star
	LDA stars_table_byte,X
	CMP #32
	BNE no_erase
	LDA stars_table_x,X
	LSR A:LSR A:TAY:LDA #32
	STA (writeptr),Y

	.no_erase
	\\ Update star x position based on speed & wrap
	CLC
	LDA stars_table_x,X
	ADC stars_table_speed,X
	CMP #MODE7_texel_width*2
	BCC no_wrap
	SBC #MODE7_texel_width*2
	.no_wrap
	STA stars_table_x,X

	\\ Calculate x char
	LSR A:LSR A:TAY

	\\ Is there something there already?
	LDA (writeptr), Y
	STA stars_table_byte,X
	CMP #32
	BNE skip_write

	\\ Plot our star
	LDA stars_table_x,X
	LSR A
	AND #&1						; odd or even
	CLC
	ADC #33						; 1 or 2 OR 32
	STA (writeptr), Y			; reuses Y as x char from above

	.skip_write

	\\ Next star
	INX
	CPX #STARS_num
	BCS return

	\\ Next row
	CLC
	LDA writeptr
	ADC #MODE7_char_width
	STA writeptr
	BCC no_carry
	INC writeptr+1
	.no_carry
	JMP loop

	.return
	RTS
}

\ ******************************************************************
\ *	Look up tables
\ ******************************************************************

.mode7_row_addr_LO
FOR n, 0, MODE7_char_height-1, 1
EQUB LO(MODE7_base_addr + n * MODE7_char_width)
NEXT

.mode7_row_addr_HI
FOR n, 0, MODE7_char_height-1, 1
EQUB HI(MODE7_base_addr + n * MODE7_char_width)
NEXT

.mod3_table					; wasteful to have all 256 entries but safer for now
FOR n, 0, 255, 1
;IF n < 128
	EQUB (n MOD 3)
;ELSE
;	EQUB (3-((256-n) MOD 3)) MOD 3	; 255=-1 -> 2, 254=-2 -> 1, 253=-3 -> 0, 252=-4 -> 2 etc.
;ENDIF
NEXT

.div3_table					; wasteful to have all 256 entries but safer for now
FOR n, 0, 255, 1
	EQUB (n DIV 3)
NEXT

.raster_y_table				; don't need 256 entries but easier for now
FOR n, 0, 255, 1
	EQUB RASTER_centre_row + RASTER_wave_rows * SIN(PI * n / 128)
NEXT

.stars_table_x
FOR n, 0, STARS_num, 1
	EQUB RND(MODE7_texel_width * 2)
NEXT

.stars_table_speed
FOR n, 0, STARS_num, 1
	EQUB 1+RND(3)
NEXT

.half_column_lookup
FOR n, 0, 192, 1
	a = n AND 1
	b = (n AND 2) / 2
	c = (n AND 4) / 4
	d = (n AND 8) / 8
	e = (n AND 16) / 16

	x = (n AND 32) / 32
	yy = (n AND 192) / 64

	IF x = 0

		IF yy = 0
			EQUB 32 + a * 16 + b * 4 + c * 1
		ELIF yy = 1
			EQUB 32 + b * 16 + c * 4 + d * 1
		ELSE
			EQUB 32 + c * 16 + d * 4 + e * 1
		ENDIF

	ELSE

		IF yy = 0
			EQUB 32 + a * 64 + b * 8 + c * 2
		ELIF yy = 1
			EQUB 32 + b * 64 + c * 8 + d * 2
		ELSE
			EQUB 32 + c * 64 + d * 8 + e * 2
		ENDIF

	ENDIF
NEXT

\ ******************************************************************
\ *	Included data
\ ******************************************************************

INCLUDE "starhalf.6502"

\ ******************************************************************
\ *	End address to be saved
\ ******************************************************************

.end


\ ******************************************************************
\ *	Space reserved for runtime buffers not preinitialised
\ ******************************************************************

.stars_table_byte
SKIP STARS_num

ALIGN &100

\ ******************************************************************
\ *	Save the code
\ ******************************************************************

SAVE "M7Plot", start, end
