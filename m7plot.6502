\ ******************************************************************
\ * TeleTexel v1
\ * Music visualiser in MODE 7
\ * Treat MODE 7 as a 76 x 75 pixel canvas (aka teletexels)
\ ******************************************************************


\ ******************************************************************
\ *	Define OS entries (could be INCLUDE bbc_os.h)
\ ******************************************************************

oswrch = &FFEE
osasci = &FFE3
osbyte = &FFF4
osword = &FFF1
EVENTV = &0220
IRQ1V = &204

INKEY_esc = 112
INKEY_w = 33
INKEY_s = 81
INKEY_a = 65
INKEY_d = 50

SEI_OP = $78
CLI_OP = $58
NOP_OP = $ea
BEQ_OP = &F0
BNE_OP = &D0

\ ******************************************************************
\ *	Define debug flags (prefer DEBUG_* naming?)
\ ******************************************************************

ENABLE_ERASE_STARS = TRUE
ENABLE_DOUBLE_BUFFER = FALSE
ENABLE_CLEAR_SCREEN = FALSE

\ ******************************************************************
\ *	Define macros (prefer MACRO_* naming?)
\ ******************************************************************

\ ******************************************************************
\ *	Define global constants
\ ******************************************************************

MODE7_base_addr = &7C00
MODE7_char_width = 40
MODE7_char_height = 25

MODE7_alpha_black = 128
MODE7_graphic_black = 144
MODE7_contiguous = 153
MODE7_separated = 154
MODE7_black_bg = 156
MODE7_new_bg = 157

PLOT_origin_col = 4				; skip first 4 coloumns (col + newbg + col + sep)
MODE7_texel_width = (MODE7_char_width - PLOT_origin_col) * 2
MODE7_texel_height = MODE7_char_height * 3

HALF_left_edge_texels = 128 - (MODE7_texel_width / 2)
HALF_right_edge_texels = 128 + (MODE7_texel_width / 2)
HALF_top_edge_rows = (129 / 3) - ((MODE7_char_height - 3) / 2)
HALF_bottom_edge_rows =(129 / 3) + ((MODE7_char_height - 3) / 2)

MIRROR_bottom_row = 24
MIRROR_top_row = 22
MIRROR_read_row = MIRROR_top_row - 1

STARS_num = 22


\ ******************************************************************
\ *	Define fast (zero page) runtime variables
\ ******************************************************************

ORG &7B
GUARD &A0

.writeptr				SKIP 2
.readptr				SKIP 2

.test_x					SKIP 1
.test_y					SKIP 1

\\ Params are all preserved
.plot_x					SKIP 1			; x coordinate in pixels
.plot_y					SKIP 1			; y coordinate in pixels
.plot_data_ptr			SKIP 2			; ptr to sprite data
.plot_data_pitch		SKIP 1			; pitch of sprite data in bytes
.plot_data_rows			SKIP 1			; number of rows of sprite data

\\ Runtime vars used during plot call
.plot_pixel_w			SKIP 1			; sprite width in chars
.plot_row_count			SKIP 1			; number of rows to plot
.plot_char_x			SKIP 1			; x position in chars absolute
.plot_char_y			SKIP 1			; y position in chars absolute

.plot_data_idx			SKIP 1			; start index into sprite data
.plot_scr_idx			SKIP 1			; running index for screen write
.plot_tmp_byte			SKIP 1			; used to combine sprite data

.mirror_byte			SKIP 1
.mirror_bit				SKIP 1

.raster_idx				SKIP 1

.old_irqv				SKIP 2
.double_buffer			SKIP 1

\ ******************************************************************
\ *	Start address to be saved
\ ******************************************************************

ORG &1900	      					; code origin (like P%=&2000)
GUARD &7C00							; ensure code size doesn't hit start of screen memory

.start

\ ******************************************************************
\ *	Code entry
\ ******************************************************************

\ ******************************************************************
\ *	Main loop sequencing tick & draw code
\ ******************************************************************

.main
{
	\\ Set MODE 7 for memory
	LDA #22: JSR oswrch
	LDA #7: JSR oswrch

	\\ Turn off cursor!
	LDA #23: JSR oswrch
	LDA #1: JSR oswrch
	LDA #0: JSR oswrch
	LDA #0: JSR oswrch
	LDA #0: JSR oswrch
	LDA #0: JSR oswrch
	LDA #0: JSR oswrch
	LDA #0: JSR oswrch
	LDA #0: JSR oswrch
	LDA #0: JSR oswrch

	\\ Initialise screen

	IF ENABLE_DOUBLE_BUFFER
	LDA &FE34:AND #&4:STA &FE34		; normal RAM main memory
	JSR teletexel_init

	LDA &FE34:ORA #&4:STA &FE34		; shadow RAM main memory
	ENDIF

	JSR teletexel_init

	\\ Initialise systems

	IF ENABLE_ERASE_STARS	
	JSR mode7_starfield_init
	ENDIF

	\\ Initialise vars

	LDA #128
	STA test_x
	LDA #129
	STA test_y
	LDA #0
	STA raster_idx

	\\ Shadow buffers
	LDA #&1
	STA double_buffer

	\\ Enable irq
	{
		SEI
		LDA IRQ1V:STA old_irqv
		LDA IRQ1V+1:STA old_irqv+1
	
		LDA #LO(irq_handler):STA IRQ1V
		LDA #HI(irq_handler):STA IRQ1V+1		; set interrupt handler
		CLI
	}

	.loop

	\\ Wait for vsync - CAN DO BETTER THAN THIS!
	LDA #19
	JSR osbyte

	IF ENABLE_CLEAR_SCREEN
	JSR mode7_erase_screen
	ENDIF

	\\ Check for keys
	{
		LDA #121
		LDX #0
		JSR osbyte
		CPX #INKEY_esc
		BEQ exit

		CPX #INKEY_w
		BNE not_w
		DEC test_y
		.not_w
		CPX #INKEY_s
		BNE not_s
		INC test_y
		.not_s
		CPX #INKEY_a
		BNE not_a
		DEC test_x
		.not_a
		CPX #INKEY_d
		BNE not_d
		INC test_x
		.not_d
	}

	LDA test_x
	STA plot_x
	LDA test_y
	STA plot_y
	LDA #LO(font33_data)
	STA plot_data_ptr
	LDA #HI(font33_data)
	STA plot_data_ptr+1
	LDA #16
	STA plot_data_pitch
	LDA #6
	STA plot_data_rows

	JSR mode7_plot_half

;	JSR mode7_raster_fx
	JSR mode7_starfield_fx
	JSR mode7_mirror_fx

	JMP loop

	\\ Until we finish
	.exit
	SEI
	LDA old_irqv:STA IRQ1V
	LDA old_irqv+1:STA IRQ1V+1		; set interrupt handler
	CLI

	.return
	RTS
}

.teletexel_init
{
	LDX #0

	.loop
	LDA mode7_row_addr_LO,X
	STA writeptr
	LDA mode7_row_addr_HI,X
	STA writeptr+1
	
	LDY #0

	CPX #MIRROR_top_row
	BCC not_mirror
	LDA #MODE7_graphic_black + 4
	STA (writeptr),Y

	INY
	LDA #MODE7_new_bg
	STA (writeptr),Y
	BNE done_mirror

	.not_mirror
	LDA #MODE7_graphic_black + 7
	STA (writeptr),Y

	INY
	LDA #MODE7_black_bg
	STA (writeptr),Y
	
	.done_mirror
	INY
	LDA #MODE7_contiguous
	STA (writeptr),Y

	INY
	LDA #MODE7_graphic_black + 7
	STA (writeptr),Y

	INX
	CPX #MODE7_char_height
	BCC loop

	.return
	RTS
}


\ ******************************************************************
\ *	MODE 7 sprite plot routine
\ * Sprite data address = plot_data_ptr
\ * X coordinate (128=centre) = plot_x
\ * Y coordinate (129=centre) = plot_y
\ * Sprite data pitch (row length in bytes) = plot_data_pitch
\ * Number rows of sprite data = plot_data_rows
\ * NB. These are preserved between calls so can be reused
\ ******************************************************************

.mode7_plot_half
{
	\\ Zero any temporary variables
	LDY #0
	STY plot_data_idx

	\\ Copy width in pixels and height in chars (bytes)
	SEC
	LDA plot_data_pitch
	SBC #1									; w = pitch - 1
	STA plot_pixel_w

	LDA plot_data_rows
	STA plot_row_count

	\\ X calcs

	\\ Check X against right edge
	LDA plot_x
	CMP #HALF_right_edge_texels
	BCC is_visible_right
	
	.not_visible
	RTS

	.is_visible_right
	\\ Check X against left edge
	CMP #HALF_left_edge_texels
	BCS no_left_clip

	\\ Check X+W against left edge
	ADC plot_pixel_w
	CMP #HALF_left_edge_texels + 1		; need an extra texel because we plot in 2 columns
	BCC not_visible

	\\ Clip left side
	\\ Don't need to set width as this is actually an index check
	\\ But do need to specify index to look up into sprite data
	SEC
	LDA #HALF_left_edge_texels
	SBC plot_x
	STA plot_data_idx

	\\ Set X to left edge
	LDA #HALF_left_edge_texels
	STA plot_x

	.no_left_clip
	\\ Check X+W against right edge
	CLC
	ADC plot_pixel_w
	CMP #HALF_right_edge_texels
	BCC no_right_clip

	\\ Set width to right edge
	\\ W = right edge - X
	LDA #HALF_right_edge_texels
	SBC plot_x
	STA plot_pixel_w

	.no_right_clip

	\\ Character pos X
	SEC
	LDA plot_x
	SBC #HALF_left_edge_texels - (PLOT_origin_col * 2)
	LSR A
	STA plot_char_x

	\\ Need sprite data here because Y clip will update sprite pointer

	\\ Read address start of sprite data - can get caller to set this?
	LDA plot_data_ptr
	STA readptr
	LDA plot_data_ptr+1
	STA readptr+1

	\\ Convert texel coordinates to chars and clip in this space

	\\ Y calcs
	LDY plot_y
	LDA mod3_table, Y
	STA plot_y_offset + 1				; ** MODIFIES CODE

	LDA div3_table, Y
	STA plot_char_y

	\\ Check char Y against bottom edge	
	CMP #HALF_bottom_edge_rows
	BCS not_visible

	\\ Check char Y against top edge
	CMP #HALF_top_edge_rows
	BCS no_clip_top

	\\ Check Y + H against top edge
	ADC plot_row_count
	CMP #HALF_top_edge_rows + 1
	BCC not_visible

	\\ Clip against top edge
	SEC
	LDA #HALF_top_edge_rows
	SBC plot_char_y
	TAX

	\\ TODO - make this loop more optimal

	\\ Need to update start index into sprite data
	.increment_top_row
	{
		CLC
		LDA readptr
		ADC plot_data_pitch				; CONST!
		STA readptr
		BCC no_carry
		INC readptr+1
		.no_carry
	}

	\\ And reduce number of rows left to actually plot
	DEC plot_row_count

	\\ H -= top edge - Y
	DEX
	BNE increment_top_row

	\\ Set Y to top edge
	LDA #HALF_top_edge_rows
	STA plot_char_y

	.no_clip_top
	\\ Check Y + H against bottom edge
	ADC plot_row_count
	CMP #HALF_bottom_edge_rows + 1
	BCC no_bottom_clip
	
	\\ Set height to bottom edge
	\\ H = bottom edge - Y
	LDA #HALF_bottom_edge_rows
	SBC plot_char_y
	STA plot_row_count

	.no_bottom_clip

	\\ Calculate screen address from coordinates
	SEC
	LDA plot_char_y
	SBC #HALF_top_edge_rows
	TAY

	\\ Look up address of row from y coordinates
	CLC
	LDA mode7_row_addr_LO, Y
	ADC plot_char_x
	STA screen_write_addr+1
	LDA mode7_row_addr_HI, Y
	ADC #0
	STA screen_write_addr+2

	\\ Set up left & right side table indices - could pre-calc the shift
	.plot_y_offset
	LDA #0								; ** SELF-MODIFIED CODE
	ASL A: ASL A: ASL A: ASL A: ASL A: ASL A
	STA plot_half_left+1				; ** MODIFIES CODE		

	ORA #&20
	STA plot_half_right+1				; ** MODIFIES CODE

	\\ Determine x offset (0 or 1) start on left or right hand column of byte
	LDX #BEQ_OP							; BEQ opcode
	LDA plot_x							; CONST!
	AND #1
	BNE x_offset_one
	LDX #BNE_OP							; BNE opcode
	.x_offset_one
	STX branch_right_half				; ** MODIFIES CODE

	\\ Plot loop
	.y_loop
	LDY plot_data_idx					; 3c - index into sprite data

	LDX #0								; 2c
	STX plot_scr_idx					; 3c - index across screen row
	STX plot_tmp_byte					; 3c

	\\ Relies on zero value above
	\\ At the start of every row we always do left or right column of byte first
	\\ So just poke the relevant branch instruction in beforehand
	; BEQ start_right_half				; when plot_x & 1 == 1 (x_offset = 1) zero flag so always taken -> right
	; BNE start_right_half				; when plot_x & 1 == 0 (x_offset = 0) zero flag so never taken -> left
	.branch_right_half
	BEQ start_right_half				; 3c - ** SELF-MODIFIED CODE

	.x_loop

	\\ Get left column of sprite data
	LDA (readptr), Y					; 6c

	\\ Turn this into MODE 7 gfx code for left column
	.plot_half_left
	ORA #&00         					; where left_header = yy0 00000 - ** SELF-MODIFIED CODE
	TAX									; 2c + 2c
	LDA half_column_lookup, X			; 4c

	\\ Store it
	STA plot_tmp_byte					; 3c - could write into later code? (any saving?)

	\\ Get right column of sprite data
	INY									; 2c

	.start_right_half
	LDA (readptr), Y					; 6c

	\\ Turn this into MODE 7 gfx code for right column
	.plot_half_right
	ORA #&20			        		; where right_header = yy1 00000 - ** SELF-MODIFIED CODE
	TAX									; 2c + 2c
	LDA half_column_lookup, X			; 4c

	\\ Combine it with left column
	ORA plot_tmp_byte       			; 3c - mask in other half

	\\ Write combined columns to screen	
	LDX plot_scr_idx					; 3c
	.screen_write_addr
	STA &7C00, X						; 5c - write to screen - ** SELF-MODIFIED CODE

	\\ For masked sprite would need:
	\\ ORA &7C00, X						; 4c
	\\ But also need to update both addresses in outer loop
	
	INX									; 2c
	STX plot_scr_idx					; 3c

	\\ ALT (mod code) ~= STA abs (4c) INC abs (6c) BCC (3c) = 13c vs 13c

	\\ Have we reached end of columns?
	INY									; 2c
	CPY plot_pixel_w					; 3c - CONST! - could be poked into memory for CPY #imm
	BCC x_loop							; 3c

	\\ Cycle count = 57 per character byte written to screen
	\\ E.g. 32 pixel width = 16 characters = 912 cycles minimum

	\\ Have we reached end of rows?
	DEC plot_row_count					; 5c
	BEQ return							; 2c

	\\ Next line on screen
	{
		CLC								; 2c
		LDA screen_write_addr+1			; 4c
		ADC #MODE7_char_width			; 2c - screen pitch
		STA screen_write_addr+1			; 4c
		BCC no_carry					; 3c
		INC screen_write_addr+2			; 6c
		.no_carry
	}

	\\ Next line of sprite data - is contiguous but > 256 bytes 
	{
		CLC								; 2c
		LDA readptr						; 3c
		ADC plot_data_pitch				; 3c - CONST!
		STA readptr						; 3c
		BCC no_carry					; 3c
		INC readptr+1					; 5c
		.no_carry
	}
	
	JMP y_loop							; 3c

	\\ Cycle count = 64 overhead per character row written to screen
	\\ E.g. 32 pixel height = 11 character rows = 704 cycles

	\\ So overall 32 x 32 full sprite plot = ((57 * 16) + 64) * 11 = 10,736 cycles :S

	.return
	RTS
}

IF 0
.mode7_erase_sprite
{
	\\ Copy width and height in chars (bytes)
	LDY #0
	LDA (plot_data_ptr),Y
	STA plot_pixel_w
	INY
	LDA (plot_data_ptr),Y
	STA plot_data_rows

	\\ Calculate screen address from coordinates

	\\ Look up address of row from y coordiante
	LDY plot_y
	LDA div3_table, Y
	TAY

	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1
	
	\\ Divide x coordinate by 2 for colum
	LDA plot_x
	LSR A							; x offset in carry

	\\ Add column to writeptr
	CLC
	ADC writeptr
	ADC #PLOT_origin_col
	STA store_screen_addr+1			; ** MODIFIES CODE
	LDA writeptr+1
	ADC #0
	STA store_screen_addr+2			; ** MODIFIES CODE

	\\ Plot loop

	\\ For each row
	LDY plot_data_rows
	.y_loop

	\\ Plot all chars
	LDX #0
	LDA #0
	.x_loop
	.store_screen_addr
	STA &7C00,X						; ** SELF-MODIFIED CODE
	INX
	CPX plot_pixel_w
	BNE x_loop

	DEY
	BEQ done

	\\ Next line
	CLC
	LDA store_screen_addr+1
	ADC #MODE7_char_width
	STA store_screen_addr+1
	LDA store_screen_addr+2
	ADC #0
	STA store_screen_addr+2
	
	JMP y_loop
	.done

	.return
	RTS
}
ENDIF

IF ENABLE_CLEAR_SCREEN
.mode7_erase_screen
{
	LDA #32
	FOR y,0,21,1
	FOR x,PLOT_origin_col,MODE7_char_width-1,1
	STA MODE7_base_addr + (y * MODE7_char_width) + x
	NEXT
	NEXT

	.return
	RTS
}
ENDIF

\ ******************************************************************
\ *	Mirror FX
\ ******************************************************************

MIRROR_read_row0_addr = (MODE7_base_addr + ((MIRROR_read_row-0) * MODE7_char_width))
MIRROR_read_row1_addr = (MODE7_base_addr + ((MIRROR_read_row-1) * MODE7_char_width))
MIRROR_read_row2_addr = (MODE7_base_addr + ((MIRROR_read_row-2) * MODE7_char_width))
MIRROR_read_row3_addr = (MODE7_base_addr + ((MIRROR_read_row-3) * MODE7_char_width))
MIRROR_read_row4_addr = (MODE7_base_addr + ((MIRROR_read_row-4) * MODE7_char_width))
MIRROR_read_row5_addr = (MODE7_base_addr + ((MIRROR_read_row-5) * MODE7_char_width))
MIRROR_read_row6_addr = (MODE7_base_addr + ((MIRROR_read_row-6) * MODE7_char_width))
MIRROR_read_row7_addr = (MODE7_base_addr + ((MIRROR_read_row-7) * MODE7_char_width))
MIRROR_read_row8_addr = (MODE7_base_addr + ((MIRROR_read_row-8) * MODE7_char_width))

MIRROR_write_row0_addr = (MODE7_base_addr + ((MIRROR_top_row+0) * MODE7_char_width))
MIRROR_write_row1_addr = (MODE7_base_addr + ((MIRROR_top_row+1) * MODE7_char_width))
MIRROR_write_row2_addr = (MODE7_base_addr + ((MIRROR_top_row+2) * MODE7_char_width))

.mode7_mirror_fx
{
	LDX #PLOT_origin_col
	.loop0
	LDA MIRROR_read_row0_addr,X
	AND #&3
	STA mirror_byte
	LDA MIRROR_read_row1_addr,X
	AND #&3
	ASL A: ASL A				; bits 0&1 become 2&3
	ORA mirror_byte
	STA mirror_byte
	LDA MIRROR_read_row2_addr,X
	AND #&3
	ASL A: ASL A
	ASL A: ASL A				; bits 0&1 become 4&5
	STA mirror_bit
	AND #&20					; take bit 5 and make it bit 6
	ASL A
	ORA #&20
	ORA mirror_bit
	ORA mirror_byte
	STA MIRROR_write_row0_addr,X
	INX
	CPX #MODE7_char_width
	BCC loop0

	LDX #PLOT_origin_col
	.loop1
	LDA MIRROR_read_row3_addr,X
	AND #&3
	STA mirror_byte
	LDA MIRROR_read_row4_addr,X
	AND #&3
	ASL A: ASL A				; bits 0&1 become 2&3
	ORA mirror_byte
	STA mirror_byte
	LDA MIRROR_read_row5_addr,X
	AND #&3
	ASL A: ASL A
	ASL A: ASL A				; bits 0&1 become 4&5
	STA mirror_bit
	AND #&20					; take bit 5 and make it bit 6
	ASL A
	ORA #&20
	ORA mirror_bit
	ORA mirror_byte
	STA MIRROR_write_row1_addr,X
	INX
	CPX #MODE7_char_width
	BCC loop1

	LDX #PLOT_origin_col
	.loop2
	LDA MIRROR_read_row6_addr,X
	AND #&3
	STA mirror_byte
	LDA MIRROR_read_row7_addr,X
	AND #&3
	ASL A: ASL A				; bits 0&1 become 2&3
	ORA mirror_byte
	STA mirror_byte
	LDA MIRROR_read_row8_addr,X
	AND #&3
	ASL A: ASL A
	ASL A: ASL A				; bits 0&1 become 4&5
	STA mirror_bit
	AND #&20					; take bit 5 and make it bit 6
	ASL A
	ORA #&20
	ORA mirror_bit
	ORA mirror_byte
	STA MIRROR_write_row2_addr,X
	INX
	CPX #MODE7_char_width
	BCC loop2

	.return
	RTS
}


\ ******************************************************************
\ *	Raster FX
\ ******************************************************************

RASTER_centre_row = 11
RASTER_wave_rows = 6
RASTER_table_inc = 8
RASTER_row0_addr = (MODE7_base_addr + ((RASTER_centre_row-6) * MODE7_char_width))
RASTER_row1_addr = (MODE7_base_addr + ((RASTER_centre_row-5) * MODE7_char_width))
RASTER_row2_addr = (MODE7_base_addr + ((RASTER_centre_row-4) * MODE7_char_width))
RASTER_row3_addr = (MODE7_base_addr + ((RASTER_centre_row-3) * MODE7_char_width))
RASTER_row4_addr = (MODE7_base_addr + ((RASTER_centre_row-2) * MODE7_char_width))
RASTER_row5_addr = (MODE7_base_addr + ((RASTER_centre_row-1) * MODE7_char_width))
RASTER_row6_addr = (MODE7_base_addr + ((RASTER_centre_row-0) * MODE7_char_width))
RASTER_row7_addr = (MODE7_base_addr + ((RASTER_centre_row+1) * MODE7_char_width))
RASTER_row8_addr = (MODE7_base_addr + ((RASTER_centre_row+2) * MODE7_char_width))
RASTER_row9_addr = (MODE7_base_addr + ((RASTER_centre_row+3) * MODE7_char_width))
RASTER_row10_addr = (MODE7_base_addr + ((RASTER_centre_row+4) * MODE7_char_width))
RASTER_row11_addr = (MODE7_base_addr + ((RASTER_centre_row+5) * MODE7_char_width))
RASTER_row12_addr = (MODE7_base_addr + ((RASTER_centre_row+6) * MODE7_char_width))

.mode7_raster_fx
{
	LDA #MODE7_black_bg
	STA RASTER_row0_addr+1
	STA RASTER_row1_addr+1
	STA RASTER_row2_addr+1
	STA RASTER_row3_addr+1
	STA RASTER_row4_addr+1
	STA RASTER_row5_addr+1
	STA RASTER_row6_addr+1
	STA RASTER_row7_addr+1
	STA RASTER_row8_addr+1
	STA RASTER_row9_addr+1
	STA RASTER_row10_addr+1
	STA RASTER_row11_addr+1
	STA RASTER_row12_addr+1

	LDX raster_idx
	LDA raster_y_table, X
	TAY
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1
	LDY #0
	LDA #MODE7_graphic_black + 1
	STA (writeptr),Y
	INY
	LDA #MODE7_new_bg
	STA (writeptr),Y

	TXA:CLC:ADC #RASTER_table_inc:TAX
	LDA raster_y_table, X
	TAY
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1
	LDY #0
	LDA #MODE7_graphic_black + 2
	STA (writeptr),Y
	INY
	LDA #MODE7_new_bg
	STA (writeptr),Y

	TXA:CLC:ADC #RASTER_table_inc:TAX
	LDA raster_y_table, X
	TAY
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1
	LDY #0
	LDA #MODE7_graphic_black + 3
	STA (writeptr),Y
	INY
	LDA #MODE7_new_bg
	STA (writeptr),Y

	TXA:CLC:ADC #RASTER_table_inc:TAX
	LDA raster_y_table, X
	TAY
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1
	LDY #0
	LDA #MODE7_graphic_black + 4
	STA (writeptr),Y
	INY
	LDA #MODE7_new_bg
	STA (writeptr),Y

	TXA:CLC:ADC #RASTER_table_inc:TAX
	LDA raster_y_table, X
	TAY
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1
	LDY #0
	LDA #MODE7_graphic_black + 5
	STA (writeptr),Y
	INY
	LDA #MODE7_new_bg
	STA (writeptr),Y

	TXA:CLC:ADC #RASTER_table_inc:TAX
	LDA raster_y_table, X
	TAY
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1
	LDY #0
	LDA #MODE7_graphic_black + 6
	STA (writeptr),Y
	INY
	LDA #MODE7_new_bg
	STA (writeptr),Y

	INC raster_idx
	INC raster_idx

	.return
	RTS
}


\ ******************************************************************
\ *	Starfield FX
\ ******************************************************************

STARS_row0_addr = (MODE7_base_addr + ((0) * MODE7_char_width))

IF ENABLE_ERASE_STARS
.mode7_starfield_init
{
	LDA #0

	LDY #STARS_num-1
	.loop
	STA stars_table_byte,Y
	DEY
	BPL loop

	.return
	RTS
}
ENDIF

.mode7_starfield_fx
{
	LDA #LO(MODE7_base_addr + PLOT_origin_col)
	STA writeptr
	LDA #HI(MODE7_base_addr + PLOT_origin_col)
	STA writeptr+1

	LDX #0
	.loop

	\\ Erase old star
	IF ENABLE_ERASE_STARS
	LDA stars_table_byte,X
	CMP #32
	BNE no_erase
	LDA stars_table_x,X
	LSR A:LSR A:TAY:LDA #32
	STA (writeptr),Y
	ENDIF

	.no_erase
	\\ Update star x position based on speed & wrap
	CLC
	LDA stars_table_x,X
	ADC stars_table_speed,X
	CMP #MODE7_texel_width*2
	BCC no_wrap
	SBC #MODE7_texel_width*2
	.no_wrap
	STA stars_table_x,X

	\\ Calculate x char
	LSR A:LSR A:TAY

	\\ Is there something there already?
	LDA (writeptr), Y
	IF ENABLE_ERASE_STARS
	STA stars_table_byte,X
	ENDIF
	CMP #32
	BNE skip_write

	\\ Plot our star
	LDA stars_table_x,X
	LSR A
	AND #&1						; odd or even
	CLC
	ADC #33						; 1 or 2 OR 32
	STA (writeptr), Y			; reuses Y as x char from above

	.skip_write

	\\ Next star
	INX
	CPX #STARS_num
	BCS return

	\\ Next row
	CLC
	LDA writeptr
	ADC #MODE7_char_width
	STA writeptr
	BCC no_carry
	INC writeptr+1
	.no_carry
	JMP loop

	.return
	RTS
}

\ ******************************************************************
\ * IRQ
\ ******************************************************************

.irq_handler
{
	LDA &FC
	PHA

	\\ Which interrupt?
	LDA &FE4D
	AND #2
	BEQ return

	\\ Acknowledge vsync interrupt
;	STA &FE4D						; if we do this then *FX19 stops working!

	\\ Set opposite buffers displayed & mapped
	IF ENABLE_DOUBLE_BUFFER
	LDA &FE34						; set bit X = 1 -> shadow RAM mapped
	AND #&FA						; set bit X = 0 -> normal RAM mapped
	ORA double_buffer				; set bit D = 1 -> shadow RAM displayed
	STA &FE34						; set bit D = 0 -> normal RAM displayed
	
	\\ Flip buffers
	LDA double_buffer
	EOR #&5
	STA double_buffer
	ENDIF

	.return
	\\ Exit
	PLA
	STA &FC
	JMP (old_irqv)		; RTI
}


\ ******************************************************************
\ *	Look up tables
\ ******************************************************************

.mode7_row_addr_LO
FOR n, 0, MODE7_char_height-1, 1
EQUB LO(MODE7_base_addr + n * MODE7_char_width)
NEXT

.mode7_row_addr_HI
FOR n, 0, MODE7_char_height-1, 1
EQUB HI(MODE7_base_addr + n * MODE7_char_width)
NEXT

.stars_table_x
FOR n, 0, STARS_num, 1
	EQUB RND(MODE7_texel_width * 2)
NEXT

.stars_table_speed
FOR n, 0, STARS_num, 1
	EQUB 1+RND(3)
NEXT

ALIGN &100
.mod3_table					; wasteful to have all 256 entries but safer for now
FOR n, 0, 255, 1
	EQUB (n MOD 3)
NEXT

ALIGN &100
.div3_table					; wasteful to have all 256 entries but safer for now
FOR n, 0, 255, 1
	EQUB (n DIV 3)
NEXT

ALIGN &100
.half_column_lookup
FOR n, 0, 192, 1
	a = n AND 1
	b = (n AND 2) / 2
	c = (n AND 4) / 4
	d = (n AND 8) / 8
	e = (n AND 16) / 16

	x = (n AND 32) / 32
	yy = (n AND 192) / 64

	IF x = 0

		IF yy = 0
			EQUB 32 + a * 16 + b * 4 + c * 1
		ELIF yy = 1
			EQUB 32 + b * 16 + c * 4 + d * 1
		ELSE
			EQUB 32 + c * 16 + d * 4 + e * 1
		ENDIF

	ELSE

		IF yy = 0
			EQUB 32 + a * 64 + b * 8 + c * 2
		ELIF yy = 1
			EQUB 32 + b * 64 + c * 8 + d * 2
		ELSE
			EQUB 32 + c * 64 + d * 8 + e * 2
		ENDIF

	ENDIF
NEXT

.raster_y_table				; don't need 256 entries but easier for now
FOR n, 0, 255, 1
	EQUB RASTER_centre_row + RASTER_wave_rows * SIN(PI * n / 128)
NEXT


\ ******************************************************************
\ *	Included data
\ ******************************************************************

INCLUDE "font.6502"

\ ******************************************************************
\ *	End address to be saved
\ ******************************************************************

.end


\ ******************************************************************
\ *	Space reserved for runtime buffers not preinitialised
\ ******************************************************************

IF ENABLE_ERASE_STARS
.stars_table_byte
SKIP STARS_num
ENDIF

ALIGN &100

\ ******************************************************************
\ *	Save the code
\ ******************************************************************

SAVE "M7Plot", start, end
